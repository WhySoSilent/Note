索引理论
--------------------------
1. 每个查询一个索引: 请记住，每个查询中数据库只会使用一个索引，因此如果要对多个字段进行查询，请确保有这些字段的复合索引(偶尔也有例外，例如:带有$or的查询里，每个$or查询的子句都能使用不同的索引，但每个子句本身是只能使用一个索引的)
2. 复合索引中的键的顺序是很重要的
3. 如果有一个a-b的复合索引，那针对a的索引就是冗余的(例外情况: 如果b是一个多建索引，同时拥有a-b和a索引还是有意义的)
4. 索引能显著减少获取文档所需的工作量。没有合适的索引，实现查询的唯一途径就是线性扫描整个文档集合


核心索引概念
--------------------------

单键索引
----

复合键索引
----
1. 复合索引里键的顺序很重要
2. 清楚了第一点后，要明白选择怎样的顺序

一般来说，一个查询里有一向要精确匹配，另一项指定了一个范围，在使用复合索引时，范围匹配的那个键放在第二个位置上

索引效率
----
每个索引都会带来一些小的维护成本,原因显而易见
对于读密集型应用而言，索引的成本一般都是合理的
关注索引与工作集大小与内存的比率，能帮你在数据增长时维护良好的性能

B tree
----


索引类型
--------------------------

唯一性索引
----
保证了集合中所有索引项的唯一性。创建唯一性索引，设置{ unique : true }选项即可
!! 在已经包含数据的集合上创建唯一性索引，会有失败的风险。在插入数据前为集合创建唯一性索引比较好，能从一开始就保证唯一性约束。

// 创建唯一性索引的例子
>db.users.ensureIndex({ username : 1 }, { unique: true })

// 在users集合上创建唯一性索引，且删除包含重复键的文档(保留哪个重复键的文档是不确定的!)
>db.users.ensureIndex({ username : 1 }, { unique: true })

稀疏索引
----
稀疏索引里，只会出现被索引键有值的文档。创建稀疏索引，指定{ sparse : ture }选项即可
索引默认都是密集型的。也就是说在一个有索引的集合里，每个文档都会有对应的索引项，哪怕文档中没有被索引键也是如此(此时键值索引值为null，则以null为值查询的键也能利用索引)
以下两种情况下，密集型索引并不合适:
1. 希望在并非出现在集合所有文档内的字段上增加唯一性索引时(此时希望插入多个没有某字段的文档会失败，想想在唯一性索引下只能容纳一个null值的文档存在)
2. 集合中大量的文档都不包含被索引的键(在这种情况下硬是创建密集型索引,索引了大量的null,有什么性能可言呢)

// 在sku上面创建一个唯一性稀疏索引(此时不存在sku键的文档不会被索引为null了)
>db.products.ensureIndex({ sku : 1 }, { unique : true , sparse : true })

// 只为关联了user_id字段的评论建立索引(假设匿名评论都没有关联该字段)
>db.reviews.ensureIndex({ user_id : 1 }, { sparse : true })

多键索引
----
MongoDB中的多键索引总是处于激活状态。被索引的字段只要是数组，数组里面的每个值都会在索引里有自己的位置(多个索引项或键最终指向同一个文档)

!! 这里的``多键索引``和``复合索引``是两个概念，不要混淆


索引管理
--------------------------

索引的创建与删除
----
ensureIndex()			创建索引
dropIndex()				删除索引(必须提供索引名称)
getIndexSpecs()		检查索引说明
通常情况下使用这些辅助方法创建索引会更方便一些，但也可以手工插入一个索引说明(辅助方法就是这么做的)

// 创建一个索引
>db.users.ensureIndex({ zip : 1 })

// 检查索引说明
>db.users.getIndexSpecs()

// 删除索引
>db.users.dropIndex("zip_1")

手工创建
----
在Shell或者所选语言里面简单地调用索引创建辅助方法，其实在特殊的 system.indexes 集合中添加一个文档来定义新的索引。要通过这样手动插入一个索引，只需要确保指定了以下这些最起码的键:
ns			命名空间
key			要索引的字段或字段的组合
name		用来指向索引的名字
以及一些额外选项，比如sparse

// 在users集合上创建索引,插入操作没有返回错误则创建成功
spec = { ns : 'docu.users' , key : { 'addresses.zip' : 1 }, name : 'zip' }
>db.system.indexes.insert(spec, true) 

// 查询system.indexes集合进行确认
>db.system.indexes.find()

要删除索引，不要以为能直接删除system.indexes里的索引文档，这个操作是被禁止的。而是要通过使用数据库命令(不是辅助方法)deleteIndexes删除索引，该命令接受一个文档作为参数，其中包含集合名称、要删除的索引名称或者用*来删除所有索引。

// 手工删除上面建立的索引
db.runCommand({ deleteIndexes : 'users' , index : 'zip' })


索引的构建
---------------------------
声明索引要小心！如果数据集很大，构建索引的过程会花很长时间。在生产环境里，这简直就是梦魇，因为没有办法终止索引构建。发生这种情况你将不得不故障转移到从节点上。
索引的构建分为两部:
1. 对要索引的值排序
2. 排序后的值被插入索引中
查看索引构建的过程，除了查看MongoDB的日志，还可以通过Shell的currentOp()方法(注意如果是在Shell里面构建索引，必须打开一个新的Shell并发地运行currentOp)

后台索引
----
在生产环境中，可以指定在后台构建索引(可以利用流量最低的窗口时间去这样做)，只需在声明索引时指定{ background : true }

// 在后台构建索引
>db.values.ensureIndex({ open : 1 }, { background : true })

离线索引
----
如果生产数据集太大， 无法在几小时内完成索引，考虑在多节点的帮助下离线(暂时下线某个节点)构建索引

备份
----
因为索引很难构建，所以你可能会很希望为它们做备份。可惜不是所有的备份方法都包含索引，例如使用mongodump和mongorestore来备份。这些工具仅仅保存了集合和索引的声明，当运行mongorestore时，所备份的所有集合上声明的索引都会被重新创建一遍。
如果想要在备份中包含索引，需要直接备份MongoDB的数据文件。

压紧
----
如果应用程序大量更新现有数据，或者执行很多大规模的删除，其结果就是索引的碎片化程度很高(虽说B数会自己合并)。碎片过多的索引大小远超你对指定数据集大小的预测，也会让索引使用更多内存。
这些情况下你可能希望重建一个或多个索引。可以删除并重建单个索引，或者，运行reIndex()命名，它会重建指定集合上的所有索引。同时注意重建过程有开销。

// 一个例子
>db.values.reIndex()